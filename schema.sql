-- Clean, hand-authored Postgres schema for flashcards
-- Idempotent and readable; safe to run multiple times

-- Ensure we operate in the public schema without changing global search_path
SET client_min_messages = warning;

-- ===============
-- Languages
-- ===============
CREATE TABLE IF NOT EXISTS public.languages (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code text NOT NULL,
    name text NOT NULL,
    CONSTRAINT languages_code_unique UNIQUE (code)
);

COMMENT ON TABLE public.languages IS 'Supported languages (e.g., ar, en).';
COMMENT ON COLUMN public.languages.code IS 'BCP-47 or ISO code (e.g., ar, en).';

-- Helpful index for lookups by language code
CREATE INDEX IF NOT EXISTS idx_languages_code ON public.languages (code);

-- ===============
-- Terms (normalized vocabulary entries)
-- ===============
CREATE TABLE IF NOT EXISTS public.terms (
    id_vocabulary integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    language_id integer NOT NULL,
    english_term text NOT NULL,
    target_language_term text NOT NULL,
    transliteration text,
    example_sentence text,
    example_sentence_explained text,
    notes text,
    learned boolean NOT NULL DEFAULT false,
    correct_counter integer NOT NULL DEFAULT 0 CHECK (correct_counter >= 0),
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT fk_terms_language FOREIGN KEY (language_id) REFERENCES public.languages(id) ON DELETE RESTRICT,
    CONSTRAINT terms_unique_pair UNIQUE (language_id, english_term, target_language_term)
);

COMMENT ON TABLE public.terms IS 'Normalized vocabulary terms tied to a language.';
COMMENT ON COLUMN public.terms.learned IS 'True if learned; corresponds to CSV 0/1.';

-- Maintain updated_at automatically
CREATE OR REPLACE FUNCTION public.set_updated_at() RETURNS trigger AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_terms_set_updated_at ON public.terms;
CREATE TRIGGER trg_terms_set_updated_at
BEFORE UPDATE ON public.terms
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_terms_language ON public.terms (language_id);
CREATE INDEX IF NOT EXISTS idx_terms_learned ON public.terms (learned);
CREATE INDEX IF NOT EXISTS idx_terms_correct_counter ON public.terms (correct_counter);
CREATE INDEX IF NOT EXISTS idx_terms_english ON public.terms (english_term);
CREATE INDEX IF NOT EXISTS idx_terms_target ON public.terms (target_language_term);

-- ===============
-- Raw import table matching your CSV (staging)
-- ===============
-- CSV headers observed in output.csv:
--   Words (English), Word (Arabic script), Word (Arabic with Roman characters),
--   Sample sentence (Arabic), Sample sentence explained, Notes, Learned, Correct Counter
CREATE TABLE IF NOT EXISTS public.vocab_raw (
    english text,
    target_script text,
    transliteration text,
    sample_sentence_target text,
    sample_sentence_explained text,
    notes text,
    learned numeric,
    correct_counter numeric
);

COMMENT ON TABLE public.vocab_raw IS 'Raw import table mirroring the spreadsheet/CSV for easy COPY.';

-- Optional: materialize raw into normalized terms (example upsert)
-- INSERT INTO public.terms (
--     language_id, english_term, target_language_term, transliteration,
--     example_sentence, example_sentence_explained, notes, learned, correct_counter
-- )
-- SELECT
--     l.id,
--     r.english,
--     r.target_script,
--     r.transliteration,
--     r.sample_sentence_target,
--     r.sample_sentence_explained,
--     r.notes,
--     (COALESCE(r.learned, 0) <> 0),
--     COALESCE(r.correct_counter, 0)::int
-- FROM public.vocab_raw r
-- JOIN public.languages l ON l.code = 'ar'
-- ON CONFLICT (language_id, english_term, target_language_term)
-- DO UPDATE SET
--     transliteration = EXCLUDED.transliteration,
--     example_sentence = EXCLUDED.example_sentence,
--     example_sentence_explained = EXCLUDED.example_sentence_explained,
--     notes = EXCLUDED.notes,
--     learned = EXCLUDED.learned,
--     correct_counter = public.terms.correct_counter + GREATEST(EXCLUDED.correct_counter, 0),
--     updated_at = now();


